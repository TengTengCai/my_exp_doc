[TOC]

# Python列表和元组的详细区别

## 一、列表和元组的区别

1. 列表是动态数组，它们不可变且可以重设长度（改变其内部元素的个数）。
2. 元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。
3. 元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存。

这些区别结实率两者在设计哲学上的不同：

- 列表可被用于保存多个互相独立对象的数据集合
- 元组用于描述一个不会改不安的事务的多个属性

## 二、列表（List）

列表一旦创建了我们就可以根据自己的需要随意改变它的内容：

```bash
>>> l = [1, 2, 3, 4, 5, 6]
>>> l[0] = l[2] * l[3]
>>> l
[12, 2, 3, 4, 5, 6]
```

另外我们可以给列边添加新的数据来增加其大小：

```bash
>>> len(l)
6
>>> l.append(7)
>>> l
[12, 2, 3, 4, 5, 6, 7]
>>> len(l)
7
```

这是因为动态数组支持resize操作，可以增加数组的容量。当一个大小为N的列表第一次需要添加数据时，Python会创建一个新的列表，足够放原来的N个元素以及额外添加的元素。不过，实际分配的并不是N+1个元素，而是M个元素，M > N, 这是为了给未来的添加预留空间。然后旧列表的数据被复制到新列表中，旧列表则会被销毁。从设计理念上来说，第一次添加可能是后续多次添加的开始，通过预留空间的做法，我们就可以减少这一分配空间的操作次数以及内存复制的次数。这点非常重要，因为内存复制可能非常的昂贵，特别是当列表大小开始增长以后。

![tu](./image/列表的添加操作.jpg)

## 三、元组（Tuple）

元组是固定且不可改变的。这意味着一旦元组被创建，和列表不同，它的内容无法被修改或它的大小也无法被改变。

```bash
>>> t = (1, 2, 3, 4)
>>> t[0] = 5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

虽然它们不支持改变大小，但是我们可以将两个元组合并成一个新元组。这一操作类似列表的resize操作，但我们不需要为新生的元组分配任何额外的空间：

```bash
>>> t1 = (1, 2, 3, 4)
>>> t2 = (5, 6, 7, 8)
>>> t1 + t2
(1, 2, 3, 4, 5, 6, 7, 8)
```

如果我们将其与列表的append操作比较，我们会看到它的复杂度是O(n)而不是列表的O(1)。这是因为对元组每添加一个新元素都会有分配和复制操作，而不是像列表那样仅在额外的空间耗尽时发生。所以元组并没有提供一个类似append的自增操作，任意两个元组相加始终返回一个新分配的元组。

![tuple](./image/元组的合并操作.jpg)

该网站为[Python Tutor](http://www.pythontutor.com/),一个能够对python运行内存可视化的网站，非常适合初学者研究，在运行过程中内存发生了什么。

元组的静态特性的另一个好处体现在一些会在Python后台发生的事情：资源缓存。

Python是一门垃圾收集语言，这意味着当一个变量不再被使用时，Python会将该变量使用的内存释放回操作系统，以供其他程序（变量）使用。然而，对于长度为1~20的元组，即使它们不在被使用，它们的空间也不会立刻还给系统，而是留待未来使用。这意味着当未来需要一个同样大小的新的元组时，我们不再需要向操作系统申请一块内存来存放数据，因为我们已经有了预留的空间。

这看上去可能是个细微的好处，但是实际上是元组一个很神奇的地方：它们可以被轻松快速地创建，因为它们可以避免跟操作系统频繁的打交道，而后者会花很长的时间。

下面举个例子会非常直观的说明问题

```bash
In [1]: %timeit l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
93.7 ns ± 3.33 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)

In [2]: %timeit t = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
18.5 ns ± 1.19 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)
```

上面的示例中显示了初始化一个列表比初始化一个元组慢了5.1倍——如果这是在一个循环中，这点差别会很快的累加起来。

